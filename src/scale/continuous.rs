use super::{ContinuousScale, ScaleBase, ScaleType};
use super::transform::{Transform, IdentityTransform, SqrtTransform, Log10Transform};
use crate::{data::compute_min_max, error::PlotError};

/// Builder for creating continuous scales with customizable properties.
///
/// This builder allows you to configure the domain (data range), axis breaks,
/// and labels before constructing a specific scale transformation.
///
/// # Examples
///
/// ```ignore
/// use gogplot::scale::continuous::Continuous;
///
/// // Create a linear scale with custom limits
/// let scale = Continuous::new()
///     .limits((0.0, 100.0))
///     .linear();
///
/// // Create a log10 scale with custom breaks and labels
/// let scale = Continuous::new()
///     .limits((1.0, 1000.0))
///     .breaks(vec![1.0, 10.0, 100.0, 1000.0])
///     .labels(vec!["1".into(), "10".into(), "100".into(), "1000".into()])
///     .log10();
/// ```
pub struct Continuous {
    limits: Option<(f64, f64)>,
    breaks: Option<Vec<f64>>,
    labels: Option<Vec<String>>,
    expand: Option<(f64, f64)>,
    lower_bound: Option<f64>,
    upper_bound: Option<f64>,
}

impl Default for Continuous {
    fn default() -> Self {
        Self::new()
    }
}

impl Continuous {
    /// Create a new scale builder with default settings.
    ///
    /// By default, limits, breaks, and labels
    /// are automatically generated using Wilkinson's Extended algorithm.
    /// A default expansion of (0.05, 0.05) is applied to add padding around the data.
    pub fn new() -> Self {
        Self {
            limits: None,
            breaks: None,
            labels: None,
            expand: Some((0.05, 0.05)), // Default 5% expansion on each side
            lower_bound: None,
            upper_bound: None,
        }
    }

    /// Set the data domain (range) for the scale.
    ///
    /// The limits define the minimum and maximum values that will be mapped
    /// to the normalized [0, 1] coordinate space. Values outside this range
    /// will be filtered out during rendering.
    ///
    /// # Arguments
    ///
    /// * `limits` - A tuple (min, max) defining the data domain
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let scale = Continuous::new()
    ///     .limits((0.0, 100.0))
    ///     .linear();
    /// ```
    pub fn limits(mut self, limits: (f64, f64)) -> Self {
        self.limits = Some(limits);
        self
    }

    /// Set custom axis break positions.
    ///
    /// Breaks are the positions in data coordinates where tick marks and
    /// grid lines will be drawn. If not specified, breaks are automatically
    /// generated using Wilkinson's Extended algorithm.
    ///
    /// # Arguments
    ///
    /// * `breaks` - A vector of data values where breaks should occur
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let scale = Continuous::new()
    ///     .breaks(vec![0.0, 25.0, 50.0, 75.0, 100.0])
    ///     .linear();
    /// ```
    pub fn breaks(mut self, breaks: Vec<f64>) -> Self {
        self.breaks = Some(breaks);
        self
    }

    /// Set custom labels for the axis breaks.
    ///
    /// Labels are the text displayed at each break position. The number of
    /// labels should match the number of breaks. If not specified, labels
    /// are automatically generated by formatting the break values.
    ///
    /// # Arguments
    ///
    /// * `labels` - A vector of strings to display at each break
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let scale = Continuous::new()
    ///     .breaks(vec![0.0, 50.0, 100.0])
    ///     .labels(vec!["Low".into(), "Medium".into(), "High".into()])
    ///     .linear();
    /// ```
    pub fn labels(mut self, labels: Vec<String>) -> Self {
        self.labels = Some(labels);
        self
    }

    /// Set the expansion factor for the scale.
    ///
    /// The expand parameter adds padding around the data range. This is similar
    /// to ggplot2's `expand` parameter and helps prevent data from sitting exactly
    /// on the axis lines.
    ///
    /// # Arguments
    ///
    /// * `expand` - A tuple (mult, add) where:
    ///   - `mult` is a multiplicative expansion (fraction of range)
    ///   - `add` is an additive expansion (in data units)
    ///
    /// The default is (0.05, 0.0) which adds 5% padding on each side.
    /// Use (0.0, 0.0) to disable expansion.
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // 5% multiplicative expansion (default-like)
    /// let scale = Continuous::new()
    ///     .expand((0.05, 0.0))
    ///     .linear();
    ///
    /// // No expansion
    /// let scale = Continuous::new()
    ///     .expand((0.0, 0.0))
    ///     .linear();
    ///
    /// // 10% expansion plus 1 unit
    /// let scale = Continuous::new()
    ///     .expand((0.1, 1.0))
    ///     .linear();
    /// ```
    pub fn expand(mut self, expand: (f64, f64)) -> Self {
        self.expand = Some(expand);
        self
    }

    /// Set a lower bound that the scale domain must respect.
    ///
    /// During training, the scale will ensure its domain extends at least to this
    /// lower bound. This is useful for ensuring meaningful baselines, like zero
    /// for bar charts or count data.
    ///
    /// # Arguments
    ///
    /// * `bound` - The minimum value the scale domain should include
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // Scale that always starts at zero (good for bar charts)
    /// let scale = Continuous::new()
    ///     .set_lower_bound(0.0)
    ///     .linear();
    /// ```
    pub fn set_lower_bound(mut self, bound: f64) -> Self {
        self.lower_bound = Some(bound);
        self
    }

    /// Set an upper bound that the scale domain must respect.
    ///
    /// During training, the scale will ensure its domain extends at least to this
    /// upper bound. This is useful for ensuring the scale covers a specific range.
    ///
    /// # Arguments
    ///
    /// * `bound` - The maximum value the scale domain should include
    ///
    /// # Examples
    ///
    /// ```ignore
    /// // Scale that always goes up to 100
    /// let scale = Continuous::new()
    ///     .set_upper_bound(100.0)
    ///     .linear();
    ///
    /// // Percentage scale from 0 to 100
    /// let scale = Continuous::new()
    ///     .set_lower_bound(0.0)
    ///     .set_upper_bound(100.0)
    ///     .linear();
    /// ```
    pub fn set_upper_bound(mut self, bound: f64) -> Self {
        self.upper_bound = Some(bound);
        self
    }

    /// Build a linear scale.
    ///
    /// Creates a scale that maps data values to normalized coordinates using
    /// a linear (identity) transformation: `f(x) = x`.
    ///
    /// This is the most common scale type and is suitable for most continuous
    /// data where there is a linear relationship.
    ///
    /// # Returns
    ///
    /// * `Ok(Linear)` - A configured linear scale
    /// * `Err(PlotError::ScaleError)` - If breaks and labels have mismatched lengths
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let scale = Continuous::new()
    ///     .limits((0.0, 100.0))
    ///     .linear()?;
    /// ```
    pub fn linear(self) -> Result<ContinuousScaleImpl, PlotError> {
        let mut scale = ContinuousScaleImpl::new(Box::new(IdentityTransform));

        if let Some(limits) = self.limits {
            scale = scale.with_limits(limits);
        }
        if let Some(breaks) = self.breaks {
            scale = scale.with_breaks(breaks);
        }
        if let Some(labels) = self.labels {
            scale = scale.with_labels(labels);
        }
        if let Some(bound) = self.lower_bound {
            scale = scale.with_lower_bound(bound);
        }
        if let Some(bound) = self.upper_bound {
            scale = scale.with_upper_bound(bound);
        }

        Ok(scale)
    }

    /// Build a square root scale.
    ///
    /// Creates a scale that maps data values to normalized coordinates using
    /// a square root transformation: `f(x) = √x`.
    ///
    /// This transformation is useful for data with moderate right skew, as it
    /// compresses larger values more than smaller values. It's particularly
    /// effective for count data or when you want to reduce the visual impact
    /// of outliers while maintaining zero as a meaningful value.
    ///
    /// # Returns
    ///
    /// * `Ok(Sqrt)` - A configured square root scale
    /// * `Err(PlotError::ScaleError)` - If breaks and labels have mismatched lengths,
    ///   or if the domain contains negative values
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let scale = Continuous::new()
    ///     .limits((0.0, 100.0))
    ///     .sqrt()?;
    /// ```
    pub fn sqrt(self) -> Result<ContinuousScaleImpl, PlotError> {
        let mut scale = ContinuousScaleImpl::new(Box::new(SqrtTransform));

        if let Some(limits) = self.limits {
            scale = scale.with_limits(limits);
        }
        if let Some(breaks) = self.breaks {
            scale = scale.with_breaks(breaks);
        }
        if let Some(labels) = self.labels {
            scale = scale.with_labels(labels);
        }
        if let Some(bound) = self.lower_bound {
            scale = scale.with_lower_bound(bound);
        }
        if let Some(bound) = self.upper_bound {
            scale = scale.with_upper_bound(bound);
        }

        Ok(scale)
    }

    /// Build a log10 (base-10 logarithmic) scale.
    ///
    /// Creates a scale that maps data values to normalized coordinates using
    /// a logarithmic transformation: `f(x) = log₁₀(x)`.
    ///
    /// This transformation is ideal for data that spans several orders of magnitude,
    /// as it spaces out small values and compresses large values. Common uses include
    /// financial data, population sizes, or any multiplicative processes.
    ///
    /// Note: The domain must contain only positive values (log is undefined for x ≤ 0).
    ///
    /// # Returns
    ///
    /// * `Ok(Log10)` - A configured log10 scale
    /// * `Err(PlotError::ScaleError)` - If breaks and labels have mismatched lengths,
    ///   or if the domain contains non-positive values
    ///
    /// # Examples
    ///
    /// ```ignore
    /// let scale = Continuous::new()
    ///     .limits((1.0, 1000.0))
    ///     .breaks(vec![1.0, 10.0, 100.0, 1000.0])
    ///     .log10()?;
    /// ```
    pub fn log10(self) -> Result<ContinuousScaleImpl, PlotError> {
        let mut scale = ContinuousScaleImpl::new(Box::new(Log10Transform));

        if let Some(limits) = self.limits {
            scale = scale.with_limits(limits);
        }
        if let Some(breaks) = self.breaks {
            scale = scale.with_breaks(breaks);
        }
        if let Some(labels) = self.labels {
            scale = scale.with_labels(labels);
        }
        if let Some(bound) = self.lower_bound {
            scale = scale.with_lower_bound(bound);
        }
        if let Some(bound) = self.upper_bound {
            scale = scale.with_upper_bound(bound);
        }

        Ok(scale)
    }
}

/// A unified continuous scale that uses pluggable transformations.
///
/// This replaces the separate `Linear`, `Sqrt`, and `Log10` structs with
/// a single implementation that accepts any `Transform` object.
pub struct ContinuousScaleImpl {
    transform: Box<dyn Transform>,
    pub(crate) domain: (f64, f64),
    pub(crate) breaks: Vec<f64>,
    pub(crate) labels: Vec<String>,
    trained: bool,
    lower_bound: Option<f64>,
    upper_bound: Option<f64>,
}

impl ContinuousScaleImpl {
    pub fn new(transform: Box<dyn Transform>) -> Self {
        Self {
            transform,
            domain: (0.0, 1.0),
            breaks: Vec::new(),
            labels: Vec::new(),
            trained: false,
            lower_bound: None,
            upper_bound: None,
        }
    }

    pub fn with_limits(mut self, limits: (f64, f64)) -> Self {
        self.domain = limits;
        self.trained = true;
        self
    }

    pub fn with_breaks(mut self, breaks: Vec<f64>) -> Self {
        self.breaks = breaks;
        self
    }

    pub fn with_labels(mut self, labels: Vec<String>) -> Self {
        self.labels = labels;
        self
    }

    pub fn with_lower_bound(mut self, bound: f64) -> Self {
        self.lower_bound = Some(bound);
        self
    }

    pub fn with_upper_bound(mut self, bound: f64) -> Self {
        self.upper_bound = Some(bound);
        self
    }
}

impl ScaleBase for ContinuousScaleImpl {
    fn scale_type(&self) -> ScaleType {
        ScaleType::Continuous
    }
    
    fn train(&mut self, data: &[&dyn crate::data::GenericVector]) {
        if let Some((mut min, mut max)) = compute_min_max(data) {
            if self.trained {
                let (curr_min, curr_max) = self.domain;
                min = min.min(curr_min);
                max = max.max(curr_max);
            }

            let (domain_min, domain_max) = self.transform.domain();
            if domain_min.is_finite() {
                min = min.max(domain_min);
            }
            if domain_max.is_finite() {
                max = max.min(domain_max);
            }

            if let Some(lower) = self.lower_bound {
                min = min.min(lower);
            }
            if let Some(upper) = self.upper_bound {
                max = max.max(upper);
            }

            let range = max - min;
            let expansion = if range.abs() < 1e-10 {
                if min.abs() < 1e-10 { 1.0 } else { min.abs() * 0.1 }
            } else {
                range * 0.05
            };

            let lower_expansion = if self.lower_bound.is_some() && min == self.lower_bound.unwrap() {
                0.0
            } else {
                expansion
            };
            let upper_expansion = if self.upper_bound.is_some() && max == self.upper_bound.unwrap() {
                0.0
            } else {
                expansion
            };

            let expanded_min = min - lower_expansion;
            let expanded_max = max + upper_expansion;

            let final_min = if domain_min.is_finite() && expanded_min < domain_min {
                domain_min
            } else {
                expanded_min
            };
            let final_max = if domain_max.is_finite() && expanded_max > domain_max {
                domain_max
            } else {
                expanded_max
            };

            self.domain = (final_min, final_max);
            self.breaks = self.transform.breaks(self.domain, 5);
            self.labels = self.breaks.iter().map(|b| self.transform.format(*b)).collect();
            self.trained = true;
        }
    }
}

impl ContinuousScale for ContinuousScaleImpl {
    fn map_value(&self, data: f64) -> Option<f64> {
        let (d0, d1) = self.domain;
        if data < d0.min(d1) || data > d0.max(d1) {
            return None;
        }

        let transformed_data = self.transform.transform(data);
        let transformed_d0 = self.transform.transform(d0);
        let transformed_d1 = self.transform.transform(d1);

        if !transformed_data.is_finite() {
            return None;
        }

        Some((transformed_data - transformed_d0) / (transformed_d1 - transformed_d0))
    }

    fn inverse(&self, value: f64) -> f64 {
        let (d0, d1) = self.domain;
        let transformed_d0 = self.transform.transform(d0);
        let transformed_d1 = self.transform.transform(d1);
        let transformed_value = transformed_d0 + value * (transformed_d1 - transformed_d0);
        self.transform.inverse(transformed_value)
    }

    fn breaks(&self) -> &[f64] {
        &self.breaks
    }

    fn labels(&self) -> &[String] {
        &self.labels
    }
}

/// Generate axis breaks using Wilkinson's Extended algorithm.
/// Returns a vector of break positions given a data range and desired number of breaks.
pub fn extended_breaks(domain: (f64, f64), n: usize) -> Vec<f64> {
    // Nice numbers to use for step sizes
    const Q: [f64; 5] = [1.0, 5.0, 2.0, 2.5, 4.0];

    let (min, max) = domain;
    if n < 2 {
        return vec![min, max];
    }

    // Handle degenerate case: single value
    if (min - max).abs() < 1e-10 {
        // Create a symmetric range around the value
        if min.abs() < 1e-10 {
            // Value is ~0, create range around 0
            return vec![-1.0, 0.0, 1.0];
        } else {
            // Create range ±10% around the value
            let range = min.abs() * 0.1;
            return vec![min - range, min, min + range];
        }
    }
    let range = max - min;
    let mut best_score = std::f64::NEG_INFINITY;
    let mut best = vec![min, max];

    for &q in &Q {
        let w = (range / (n as f64 - 1.0)) / q;
        let step = q * 10f64.powf(w.log10().floor());
        let start = (min / step).floor() * step;
        let end = (max / step).ceil() * step;
        let mut breaks = Vec::new();
        let mut x = start;
        while x <= end + 1e-10 {
            breaks.push(x);
            x += step;
        }
        // Score: coverage, simplicity, density, legibility (simplified)
        let coverage = (min - breaks[0]).abs() + (breaks.last().unwrap() - max).abs();
        let simplicity = if q == 1.0 { 1.0 } else { 0.5 };
        let density = (breaks.len() as f64 - n as f64).abs();
        let score = -coverage - density + simplicity;
        if score > best_score {
            best_score = score;
            best = breaks;
        }
    }
    best
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils::dataframe::FloatVec;

    #[test]
    fn test_extended_breaks_basic() {
        let breaks = extended_breaks((0.0, 10.0), 5);
        assert_eq!(breaks, vec![0.0, 2.5, 5.0, 7.5, 10.0]);
    }

    #[test]
    fn test_extended_breaks_negative() {
        let breaks = extended_breaks((-5.0, 5.0), 5);
        assert_eq!(breaks, vec![-5.0, -2.5, 0.0, 2.5, 5.0]);
    }

    #[test]
    fn test_extended_breaks_single_value_zero() {
        // When min == max and close to zero, should return [-1, 0, 1]
        let breaks = extended_breaks((0.0, 0.0), 5);
        assert_eq!(breaks, vec![-1.0, 0.0, 1.0]);
    }

    #[test]
    fn test_extended_breaks_single_value_nonzero() {
        // When min == max and non-zero, should return symmetric range around value
        let breaks = extended_breaks((10.0, 10.0), 5);
        assert_eq!(breaks, vec![9.0, 10.0, 11.0]);
    }

    #[test]
    fn test_extended_breaks_single_value_negative() {
        // Test with negative single value
        let breaks = extended_breaks((-5.0, -5.0), 5);
        assert_eq!(breaks, vec![-5.5, -5.0, -4.5]);
    }

    #[test]
    fn test_linear_scale_degenerate_zero() {
        // Test Linear scale with all values at zero
        // Using Builder without limits means train() will be called
        let mut scale = Continuous::new().linear().unwrap();
        let data = FloatVec(vec![0.0, 0.0, 0.0, 0.0]);
        scale.train(&[&data]);

        // Should have symmetric domain around zero
        assert!(
            scale.domain.0 < 0.0,
            "domain.0 should be < 0.0, got {}",
            scale.domain.0
        );
        assert!(
            scale.domain.1 > 0.0,
            "domain.1 should be > 0.0, got {}",
            scale.domain.1
        );

        // Should be able to map the value without division by zero
        let mapped = scale.map_value(0.0);
        assert!(mapped.is_some(), "Should be able to map 0.0");
        // Value should map near the middle of the range
        assert!(
            (mapped.unwrap() - 0.5).abs() < 0.1,
            "0.0 should map near 0.5, got {}",
            mapped.unwrap()
        );
    }

    #[test]
    fn test_linear_scale_degenerate_nonzero() {
        // Test Linear scale with all values at 5.0
        let mut scale = Continuous::new().linear().unwrap();
        let data = FloatVec(vec![5.0, 5.0, 5.0]);
        scale.train(&[&data]);

        // Should have symmetric domain around 5.0
        assert!(
            scale.domain.0 < 5.0,
            "domain.0 should be < 5.0, got {}",
            scale.domain.0
        );
        assert!(
            scale.domain.1 > 5.0,
            "domain.1 should be > 5.0, got {}",
            scale.domain.1
        );

        // Should be able to map the value without division by zero
        let mapped = scale.map_value(5.0);
        assert!(mapped.is_some(), "Should be able to map 5.0");
        // Value should map near the middle of the range
        assert!(
            (mapped.unwrap() - 0.5).abs() < 0.1,
            "5.0 should map near 0.5, got {}",
            mapped.unwrap()
        );
    }

    #[test]
    fn test_sqrt_scale_degenerate() {
        // Test Sqrt scale with all values at 4.0
        let mut scale = Continuous::new().sqrt().unwrap();
        let data = FloatVec(vec![4.0, 4.0, 4.0]);
        scale.train(&[&data]);

        // Should have symmetric domain around 4.0
        assert!(
            scale.domain.0 < 4.0,
            "domain.0 should be < 4.0, got {}",
            scale.domain.0
        );
        assert!(
            scale.domain.1 > 4.0,
            "domain.1 should be > 4.0, got {}",
            scale.domain.1
        );

        // Should be able to map the value without division by zero
        let mapped = scale.map_value(4.0);
        assert!(mapped.is_some(), "Should be able to map 4.0");
        // Value should map near the middle of the range
        assert!(
            (mapped.unwrap() - 0.5).abs() < 0.1,
            "4.0 should map near 0.5, got {}",
            mapped.unwrap()
        );
    }

    #[test]
    fn test_log10_scale_degenerate() {
        // Test Log10 scale with all values at 10.0
        let mut scale = Continuous::new().log10().unwrap();
        let data = FloatVec(vec![10.0, 10.0, 10.0]);
        scale.train(&[&data]);

        // Should have expanded domain around 10.0
        assert!(
            scale.domain.0 < 10.0,
            "domain.0 should be < 10.0, got {}",
            scale.domain.0
        );
        assert!(
            scale.domain.1 > 10.0,
            "domain.1 should be > 10.0, got {}",
            scale.domain.1
        );

        // Should be able to map the value without division by zero
        let mapped = scale.map_value(10.0);
        assert!(mapped.is_some(), "Should be able to map 10.0");
        // Value should map near the middle of the range
        assert!(
            (mapped.unwrap() - 0.5).abs() < 0.1,
            "10.0 should map near 0.5, got {}",
            mapped.unwrap()
        );
    }

    #[test]
    fn test_linear_scale_degenerate_preserves_normal_behavior() {
        // Ensure the fix doesn't break normal scaling
        let mut scale = Continuous::new().linear().unwrap();
        let data = FloatVec(vec![0.0, 10.0]);
        scale.train(&[&data]);

        // With 5% expansion on each side, domain is approximately [-0.5, 10.5]
        // So 0.0 maps to about 0.048 (0.5 / 10.5), not exactly 0.0
        let map_0 = scale.map_value(0.0).unwrap();
        let map_10 = scale.map_value(10.0).unwrap();
        let map_5 = scale.map_value(5.0).unwrap();

        assert!(map_0 < 0.1, "0.0 should map near the start, got {}", map_0);
        assert!(map_10 > 0.9, "10.0 should map near the end, got {}", map_10);
        assert!(
            (map_5 - 0.5).abs() < 0.1,
            "5.0 should map near 0.5, got {}",
            map_5
        );
    }

    #[test]
    fn test_sqrt_scale_degenerate_preserves_normal_behavior() {
        // Ensure the fix doesn't break normal scaling
        let mut scale = Continuous::new().sqrt().unwrap();
        let data = FloatVec(vec![0.0, 100.0]);
        scale.train(&[&data]);

        let map_0 = scale.map_value(0.0).unwrap();
        let map_100 = scale.map_value(100.0).unwrap();
        let map_25 = scale.map_value(25.0).unwrap();

        assert!(map_0 < 0.1, "0.0 should map near the start, got {}", map_0);
        assert!(
            map_100 > 0.9,
            "100.0 should map near the end, got {}",
            map_100
        );
        // sqrt(25) = 5, halfway between sqrt(0)=0 and sqrt(100)=10
        assert!(
            (map_25 - 0.5).abs() < 0.1,
            "25.0 should map near 0.5, got {}",
            map_25
        );
    }

    #[test]
    fn test_log10_scale_degenerate_preserves_normal_behavior() {
        // Ensure the fix doesn't break normal scaling
        let mut scale = Continuous::new().log10().unwrap();
        let data = FloatVec(vec![1.0, 100.0]);
        scale.train(&[&data]);

        let map_1 = scale.map_value(1.0).unwrap();
        let map_100 = scale.map_value(100.0).unwrap();
        let map_10 = scale.map_value(10.0).unwrap();

        // With expansion, domain is roughly (0.95, 105) but clamped to transformation's
        // domain (1e-300, inf), so the lower bound clamps to 1e-300, making the log
        // space domain very wide: log10(1e-300) = -300 to log10(105) ≈ 2
        // This means 10 maps very close to 1.0:
        // (log10(10) - (-300)) / (2 - (-300)) = 301/302 ≈ 0.997
        assert!(map_1 < map_10, "1.0 should map before 10.0");
        assert!(map_10 < map_100, "10.0 should map before 100.0");
        // Due to the very small lower bound (1e-300), 10 will map very close to upper bound
        assert!(
            map_10 > 0.99,
            "10.0 should map near upper bound due to log scale with tiny lower limit, got {}",
            map_10
        );
    }
}
