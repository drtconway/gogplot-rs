use super::{ScaleBase, ContinuousScale};
use crate::error::PlotError;

/// Builder for creating continuous scales with customizable properties.
/// 
/// This builder allows you to configure the domain (data range), axis breaks,
/// and labels before constructing a specific scale transformation.
/// 
/// # Examples
/// 
/// ```ignore
/// use gogplot_rs::scale::continuous::Builder;
/// 
/// // Create a linear scale with custom limits
/// let scale = Builder::new()
///     .limits((0.0, 100.0))
///     .linear();
/// 
/// // Create a log10 scale with custom breaks and labels
/// let scale = Builder::new()
///     .limits((1.0, 1000.0))
///     .breaks(vec![1.0, 10.0, 100.0, 1000.0])
///     .labels(vec!["1".into(), "10".into(), "100".into(), "1000".into()])
///     .log10();
/// ```
pub struct Builder {
    limits: Option<(f64, f64)>,
    breaks: Option<Vec<f64>>,
    labels: Option<Vec<String>>,
}

impl Builder {
    /// Create a new scale builder with default settings.
    /// 
    /// By default, limits, breaks, and labels
    /// are automatically generated using Wilkinson's Extended algorithm.
    pub fn new() -> Self {
        Self {
            limits: None,
            breaks: None,
            labels: None,
        }
    }

    /// Set the data domain (range) for the scale.
    /// 
    /// The limits define the minimum and maximum values that will be mapped
    /// to the normalized [0, 1] coordinate space. Values outside this range
    /// will be filtered out during rendering.
    /// 
    /// # Arguments
    /// 
    /// * `limits` - A tuple (min, max) defining the data domain
    /// 
    /// # Examples
    /// 
    /// ```ignore
    /// let scale = Builder::new()
    ///     .limits((0.0, 100.0))
    ///     .linear();
    /// ```
    pub fn limits(mut self, limits: (f64, f64)) -> Self {
        self.limits = Some(limits);
        self
    }

    /// Set custom axis break positions.
    /// 
    /// Breaks are the positions in data coordinates where tick marks and
    /// grid lines will be drawn. If not specified, breaks are automatically
    /// generated using Wilkinson's Extended algorithm.
    /// 
    /// # Arguments
    /// 
    /// * `breaks` - A vector of data values where breaks should occur
    /// 
    /// # Examples
    /// 
    /// ```ignore
    /// let scale = Builder::new()
    ///     .breaks(vec![0.0, 25.0, 50.0, 75.0, 100.0])
    ///     .linear();
    /// ```
    pub fn breaks(mut self, breaks: Vec<f64>) -> Self {
        self.breaks = Some(breaks);
        self
    }

    /// Set custom labels for the axis breaks.
    /// 
    /// Labels are the text displayed at each break position. The number of
    /// labels should match the number of breaks. If not specified, labels
    /// are automatically generated by formatting the break values.
    /// 
    /// # Arguments
    /// 
    /// * `labels` - A vector of strings to display at each break
    /// 
    /// # Examples
    /// 
    /// ```ignore
    /// let scale = Builder::new()
    ///     .breaks(vec![0.0, 50.0, 100.0])
    ///     .labels(vec!["Low".into(), "Medium".into(), "High".into()])
    ///     .linear();
    /// ```
    pub fn labels(mut self, labels: Vec<String>) -> Self {
        self.labels = Some(labels);
        self
    }

    /// Build a linear scale.
    /// 
    /// Creates a scale that maps data values to normalized coordinates using
    /// a linear (identity) transformation: `f(x) = x`.
    /// 
    /// This is the most common scale type and is suitable for most continuous
    /// data where there is a linear relationship.
    /// 
    /// # Returns
    /// 
    /// * `Ok(Linear)` - A configured linear scale
    /// * `Err(PlotError::ScaleError)` - If breaks and labels have mismatched lengths
    /// 
    /// # Examples
    /// 
    /// ```ignore
    /// let scale = Builder::new()
    ///     .limits((0.0, 100.0))
    ///     .linear()?;
    /// ```
    pub fn linear(self) -> Result<Linear, PlotError> {
        let domain = self.limits.unwrap_or((0.0, 1.0));
        let breaks = self
            .breaks
            .unwrap_or_else(|| extended_breaks(domain, 5));
        
        let labels = self.labels.unwrap_or_else(|| {
            breaks.iter().map(|b| format!("{:.2}", b)).collect()
        });

        if breaks.len() != labels.len() {
            return Err(PlotError::ScaleError(
                format!("Breaks and labels must have the same length: {} breaks vs {} labels",
                    breaks.len(), labels.len())
            ));
        }

        Ok(Linear {
            domain,
            breaks,
            labels,
        })
    }

    /// Build a square root scale.
    /// 
    /// Creates a scale that maps data values to normalized coordinates using
    /// a square root transformation: `f(x) = √x`.
    /// 
    /// This transformation is useful for data with moderate right skew, as it
    /// compresses larger values more than smaller values. It's particularly
    /// effective for count data or when you want to reduce the visual impact
    /// of outliers while maintaining zero as a meaningful value.
    /// 
    /// # Returns
    /// 
    /// * `Ok(Sqrt)` - A configured square root scale
    /// * `Err(PlotError::ScaleError)` - If breaks and labels have mismatched lengths,
    ///   or if the domain contains negative values
    /// 
    /// # Examples
    /// 
    /// ```ignore
    /// let scale = Builder::new()
    ///     .limits((0.0, 100.0))
    ///     .sqrt()?;
    /// ```
    pub fn sqrt(self) -> Result<Sqrt, PlotError> {
        let domain = self.limits.unwrap_or((0.0, 1.0));
        
        if domain.0 < 0.0 || domain.1 < 0.0 {
            return Err(PlotError::ScaleError(
                format!("Square root scale requires non-negative domain, got ({}, {})",
                    domain.0, domain.1)
            ));
        }
        
        let breaks = self
            .breaks
            .unwrap_or_else(|| extended_breaks(domain, 5));
        
        let labels = self.labels.unwrap_or_else(|| {
            breaks.iter().map(|b| format!("{:.2}", b)).collect()
        });

        if breaks.len() != labels.len() {
            return Err(PlotError::ScaleError(
                format!("Breaks and labels must have the same length: {} breaks vs {} labels",
                    breaks.len(), labels.len())
            ));
        }

        Ok(Sqrt {
            domain,
            breaks,
            labels,
        })
    }

    /// Build a log10 (base-10 logarithmic) scale.
    /// 
    /// Creates a scale that maps data values to normalized coordinates using
    /// a logarithmic transformation: `f(x) = log₁₀(x)`.
    /// 
    /// This transformation is ideal for data that spans several orders of magnitude,
    /// as it spaces out small values and compresses large values. Common uses include
    /// financial data, population sizes, or any multiplicative processes.
    /// 
    /// Note: The domain must contain only positive values (log is undefined for x ≤ 0).
    /// 
    /// # Returns
    /// 
    /// * `Ok(Log10)` - A configured log10 scale
    /// * `Err(PlotError::ScaleError)` - If breaks and labels have mismatched lengths,
    ///   or if the domain contains non-positive values
    /// 
    /// # Examples
    /// 
    /// ```ignore
    /// let scale = Builder::new()
    ///     .limits((1.0, 1000.0))
    ///     .breaks(vec![1.0, 10.0, 100.0, 1000.0])
    ///     .log10()?;
    /// ```
    pub fn log10(self) -> Result<Log10, PlotError> {
        let domain = self.limits.unwrap_or((1.0, 10.0));
        
        if domain.0 <= 0.0 || domain.1 <= 0.0 {
            return Err(PlotError::ScaleError(
                format!("Log10 scale requires positive domain, got ({}, {})",
                    domain.0, domain.1)
            ));
        }
        
        let breaks = self
            .breaks
            .unwrap_or_else(|| extended_breaks(domain, 5));
        
        let labels = self.labels.unwrap_or_else(|| {
            breaks.iter().map(|b| format!("{:.2}", b)).collect()
        });

        if breaks.len() != labels.len() {
            return Err(PlotError::ScaleError(
                format!("Breaks and labels must have the same length: {} breaks vs {} labels",
                    breaks.len(), labels.len())
            ));
        }

        Ok(Log10 {
            domain,
            breaks,
            labels,
        })
    }
}

pub struct Linear {
    pub(crate) domain: (f64, f64),
    pub(crate) breaks: Vec<f64>,
    pub(crate) labels: Vec<String>,
}

impl ScaleBase for Linear {
    fn train(&mut self, _data: &dyn crate::data::GenericVector) {
        // Training could recalculate domain from data
        // For now, domain is set explicitly via builder
    }
}

impl ContinuousScale for Linear {
    fn map_value(&self, data: f64) -> Option<f64> {
        let (d0, d1) = self.domain;
        // Check if value is within domain bounds
        if data < d0.min(d1) || data > d0.max(d1) {
            return None;
        }
        // Map to normalized [0, 1] coordinates
        Some((data - d0) / (d1 - d0))
    }

    fn inverse(&self, value: f64) -> f64 {
        let (d0, d1) = self.domain;
        // Map from normalized [0, 1] to data domain
        d0 + value * (d1 - d0)
    }

    fn breaks(&self) -> &[f64] {
        &self.breaks
    }

    fn labels(&self) -> &[String] {
        &self.labels
    }
}

pub struct Sqrt {
    pub(crate) domain: (f64, f64),
    pub(crate) breaks: Vec<f64>,
    pub(crate) labels: Vec<String>,
}

impl ScaleBase for Sqrt {
    fn train(&mut self, _data: &dyn crate::data::GenericVector) {
        // Training could recalculate domain from data
    }
}

impl ContinuousScale for Sqrt {
    fn map_value(&self, data: f64) -> Option<f64> {
        let (d0, d1) = self.domain;
        // Check if value is within domain bounds
        if data < d0.min(d1) || data > d0.max(d1) {
            return None;
        }
        // Map to normalized [0, 1] using sqrt transformation
        let sqrt_data = data.sqrt();
        let sqrt_d0 = d0.sqrt();
        let sqrt_d1 = d1.sqrt();
        Some((sqrt_data - sqrt_d0) / (sqrt_d1 - sqrt_d0))
    }

    fn inverse(&self, value: f64) -> f64 {
        let (d0, d1) = self.domain;
        let sqrt_d0 = d0.sqrt();
        let sqrt_d1 = d1.sqrt();
        // Map from normalized [0, 1] to data domain
        let scaled = sqrt_d0 + value * (sqrt_d1 - sqrt_d0);
        scaled * scaled
    }

    fn breaks(&self) -> &[f64] {
        &self.breaks
    }

    fn labels(&self) -> &[String] {
        &self.labels
    }
}

pub struct Log10 {
    pub(crate) domain: (f64, f64),
    pub(crate) breaks: Vec<f64>,
    pub(crate) labels: Vec<String>,
}

impl ScaleBase for Log10 {
    fn train(&mut self, _data: &dyn crate::data::GenericVector) {
        // Training could recalculate domain from data
    }
}

impl ContinuousScale for Log10 {
    fn map_value(&self, data: f64) -> Option<f64> {
        let (d0, d1) = self.domain;
        // Check if value is within domain bounds
        if data < d0.min(d1) || data > d0.max(d1) {
            return None;
        }
        // Map to normalized [0, 1] using log10 transformation
        let log_data = data.log10();
        let log_d0 = d0.log10();
        let log_d1 = d1.log10();
        Some((log_data - log_d0) / (log_d1 - log_d0))
    }

    fn inverse(&self, value: f64) -> f64 {
        let (d0, d1) = self.domain;
        let log_d0 = d0.log10();
        let log_d1 = d1.log10();
        // Map from normalized [0, 1] to data domain
        let scaled = log_d0 + value * (log_d1 - log_d0);
        10_f64.powf(scaled)
    }

    fn breaks(&self) -> &[f64] {
        &self.breaks
    }

    fn labels(&self) -> &[String] {
        &self.labels
    }
}

/// Generate axis breaks using Wilkinson's Extended algorithm.
/// Returns a vector of break positions given a data range and desired number of breaks.
pub fn extended_breaks(domain: (f64, f64), n: usize) -> Vec<f64> {
    // Nice numbers to use for step sizes
    const Q: [f64; 5] = [1.0, 5.0, 2.0, 2.5, 4.0];

    let (min, max) = domain;
    if n < 2 || min == max {
        return vec![min, max];
    }
    let range = max - min;
    let mut best_score = std::f64::NEG_INFINITY;
    let mut best = vec![min, max];

    for &q in &Q {
        let w = (range / (n as f64 - 1.0)) / q;
        let step = q * 10f64.powf(w.log10().floor());
        let start = (min / step).floor() * step;
        let end = (max / step).ceil() * step;
        let mut breaks = Vec::new();
        let mut x = start;
        while x <= end + 1e-10 {
            breaks.push(x);
            x += step;
        }
        // Score: coverage, simplicity, density, legibility (simplified)
        let coverage = (min - breaks[0]).abs() + (breaks.last().unwrap() - max).abs();
        let simplicity = if q == 1.0 { 1.0 } else { 0.5 };
        let density = ((breaks.len() as f64 - n as f64).abs()) as f64;
        let score = -coverage - density + simplicity;
        if score > best_score {
            best_score = score;
            best = breaks;
        }
    }
    best
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_extended_breaks_basic() {
        let breaks = extended_breaks((0.0, 10.0), 5);
        assert_eq!(breaks, vec![0.0, 2.5, 5.0, 7.5, 10.0]);
    }

    #[test]
    fn test_extended_breaks_negative() {
        let breaks = extended_breaks((-5.0, 5.0), 5);
        assert_eq!(breaks, vec![-5.0, -2.5, 0.0, 2.5, 5.0]);
    }
}