use super::{ScaleBase, ContinuousScale};
use crate::error::PlotError;

/// Builder for creating continuous scales with customizable properties.
/// 
/// This builder allows you to configure the domain (data range), axis breaks,
/// and labels before constructing a specific scale transformation.
/// 
/// # Examples
/// 
/// ```ignore
/// use gogplot_rs::scale::continuous::Continuous;
/// 
/// // Create a linear scale with custom limits
/// let scale = Continuous::new()
///     .limits((0.0, 100.0))
///     .linear();
/// 
/// // Create a log10 scale with custom breaks and labels
/// let scale = Continuous::new()
///     .limits((1.0, 1000.0))
///     .breaks(vec![1.0, 10.0, 100.0, 1000.0])
///     .labels(vec!["1".into(), "10".into(), "100".into(), "1000".into()])
///     .log10();
/// ```
pub struct Continuous {
    limits: Option<(f64, f64)>,
    breaks: Option<Vec<f64>>,
    labels: Option<Vec<String>>,
    expand: Option<(f64, f64)>,
    lower_bound: Option<f64>,
    upper_bound: Option<f64>,
}

impl Continuous {
    /// Create a new scale builder with default settings.
    /// 
    /// By default, limits, breaks, and labels
    /// are automatically generated using Wilkinson's Extended algorithm.
    /// A default expansion of (0.05, 0.05) is applied to add padding around the data.
    pub fn new() -> Self {
        Self {
            limits: None,
            breaks: None,
            labels: None,
            expand: Some((0.05, 0.05)), // Default 5% expansion on each side
            lower_bound: None,
            upper_bound: None,
        }
    }

    /// Set the data domain (range) for the scale.
    /// 
    /// The limits define the minimum and maximum values that will be mapped
    /// to the normalized [0, 1] coordinate space. Values outside this range
    /// will be filtered out during rendering.
    /// 
    /// # Arguments
    /// 
    /// * `limits` - A tuple (min, max) defining the data domain
    /// 
    /// # Examples
    /// 
    /// ```ignore
    /// let scale = Continuous::new()
    ///     .limits((0.0, 100.0))
    ///     .linear();
    /// ```
    pub fn limits(mut self, limits: (f64, f64)) -> Self {
        self.limits = Some(limits);
        self
    }

    /// Set custom axis break positions.
    /// 
    /// Breaks are the positions in data coordinates where tick marks and
    /// grid lines will be drawn. If not specified, breaks are automatically
    /// generated using Wilkinson's Extended algorithm.
    /// 
    /// # Arguments
    /// 
    /// * `breaks` - A vector of data values where breaks should occur
    /// 
    /// # Examples
    /// 
    /// ```ignore
    /// let scale = Continuous::new()
    ///     .breaks(vec![0.0, 25.0, 50.0, 75.0, 100.0])
    ///     .linear();
    /// ```
    pub fn breaks(mut self, breaks: Vec<f64>) -> Self {
        self.breaks = Some(breaks);
        self
    }

    /// Set custom labels for the axis breaks.
    /// 
    /// Labels are the text displayed at each break position. The number of
    /// labels should match the number of breaks. If not specified, labels
    /// are automatically generated by formatting the break values.
    /// 
    /// # Arguments
    /// 
    /// * `labels` - A vector of strings to display at each break
    /// 
    /// # Examples
    /// 
    /// ```ignore
    /// let scale = Continuous::new()
    ///     .breaks(vec![0.0, 50.0, 100.0])
    ///     .labels(vec!["Low".into(), "Medium".into(), "High".into()])
    ///     .linear();
    /// ```
    pub fn labels(mut self, labels: Vec<String>) -> Self {
        self.labels = Some(labels);
        self
    }

    /// Set the expansion factor for the scale.
    /// 
    /// The expand parameter adds padding around the data range. This is similar
    /// to ggplot2's `expand` parameter and helps prevent data from sitting exactly
    /// on the axis lines.
    /// 
    /// # Arguments
    /// 
    /// * `expand` - A tuple (mult, add) where:
    ///   - `mult` is a multiplicative expansion (fraction of range)
    ///   - `add` is an additive expansion (in data units)
    /// 
    /// The default is (0.05, 0.0) which adds 5% padding on each side.
    /// Use (0.0, 0.0) to disable expansion.
    /// 
    /// # Examples
    /// 
    /// ```ignore
    /// // 5% multiplicative expansion (default-like)
    /// let scale = Continuous::new()
    ///     .expand((0.05, 0.0))
    ///     .linear();
    /// 
    /// // No expansion
    /// let scale = Continuous::new()
    ///     .expand((0.0, 0.0))
    ///     .linear();
    /// 
    /// // 10% expansion plus 1 unit
    /// let scale = Continuous::new()
    ///     .expand((0.1, 1.0))
    ///     .linear();
    /// ```
    pub fn expand(mut self, expand: (f64, f64)) -> Self {
        self.expand = Some(expand);
        self
    }

    /// Set a lower bound that the scale domain must respect.
    /// 
    /// During training, the scale will ensure its domain extends at least to this
    /// lower bound. This is useful for ensuring meaningful baselines, like zero
    /// for bar charts or count data.
    /// 
    /// # Arguments
    /// 
    /// * `bound` - The minimum value the scale domain should include
    /// 
    /// # Examples
    /// 
    /// ```ignore
    /// // Scale that always starts at zero (good for bar charts)
    /// let scale = Continuous::new()
    ///     .set_lower_bound(0.0)
    ///     .linear();
    /// ```
    pub fn set_lower_bound(mut self, bound: f64) -> Self {
        self.lower_bound = Some(bound);
        self
    }

    /// Set an upper bound that the scale domain must respect.
    /// 
    /// During training, the scale will ensure its domain extends at least to this
    /// upper bound. This is useful for ensuring the scale covers a specific range.
    /// 
    /// # Arguments
    /// 
    /// * `bound` - The maximum value the scale domain should include
    /// 
    /// # Examples
    /// 
    /// ```ignore
    /// // Scale that always goes up to 100
    /// let scale = Continuous::new()
    ///     .set_upper_bound(100.0)
    ///     .linear();
    /// 
    /// // Percentage scale from 0 to 100
    /// let scale = Continuous::new()
    ///     .set_lower_bound(0.0)
    ///     .set_upper_bound(100.0)
    ///     .linear();
    /// ```
    pub fn set_upper_bound(mut self, bound: f64) -> Self {
        self.upper_bound = Some(bound);
        self
    }

    /// Build a linear scale.
    /// 
    /// Creates a scale that maps data values to normalized coordinates using
    /// a linear (identity) transformation: `f(x) = x`.
    /// 
    /// This is the most common scale type and is suitable for most continuous
    /// data where there is a linear relationship.
    /// 
    /// # Returns
    /// 
    /// * `Ok(Linear)` - A configured linear scale
    /// * `Err(PlotError::ScaleError)` - If breaks and labels have mismatched lengths
    /// 
    /// # Examples
    /// 
    /// ```ignore
    /// let scale = Continuous::new()
    ///     .limits((0.0, 100.0))
    ///     .linear()?;
    /// ```
    pub fn linear(self) -> Result<Linear, PlotError> {
        let mut domain = self.limits.unwrap_or((0.0, 1.0));
        
        // Apply expansion
        if let Some((mult, add)) = self.expand {
            let range = domain.1 - domain.0;
            let expansion = range * mult + add;
            domain.0 -= expansion;
            domain.1 += expansion;
        }
        
        let breaks = self
            .breaks
            .unwrap_or_else(|| extended_breaks(domain, 5));
        
        let labels = self.labels.unwrap_or_else(|| {
            breaks.iter().map(|b| format!("{:.2}", b)).collect()
        });

        if breaks.len() != labels.len() {
            return Err(PlotError::ScaleError(
                format!("Breaks and labels must have the same length: {} breaks vs {} labels",
                    breaks.len(), labels.len())
            ));
        }

        Ok(Linear {
            domain,
            breaks,
            labels,
            trained: self.limits.is_some(), // If limits were explicitly set, mark as trained
            lower_bound: self.lower_bound,
            upper_bound: self.upper_bound,
        })
    }

    /// Build a square root scale.
    /// 
    /// Creates a scale that maps data values to normalized coordinates using
    /// a square root transformation: `f(x) = √x`.
    /// 
    /// This transformation is useful for data with moderate right skew, as it
    /// compresses larger values more than smaller values. It's particularly
    /// effective for count data or when you want to reduce the visual impact
    /// of outliers while maintaining zero as a meaningful value.
    /// 
    /// # Returns
    /// 
    /// * `Ok(Sqrt)` - A configured square root scale
    /// * `Err(PlotError::ScaleError)` - If breaks and labels have mismatched lengths,
    ///   or if the domain contains negative values
    /// 
    /// # Examples
    /// 
    /// ```ignore
    /// let scale = Continuous::new()
    ///     .limits((0.0, 100.0))
    ///     .sqrt()?;
    /// ```
    pub fn sqrt(self) -> Result<Sqrt, PlotError> {
        let mut domain = self.limits.unwrap_or((0.0, 1.0));
        
        if domain.0 < 0.0 || domain.1 < 0.0 {
            return Err(PlotError::ScaleError(
                format!("Square root scale requires non-negative domain, got ({}, {})",
                    domain.0, domain.1)
            ));
        }
        
        // Apply expansion
        if let Some((mult, add)) = self.expand {
            let range = domain.1 - domain.0;
            let expansion = range * mult + add;
            domain.0 = (domain.0 - expansion).max(0.0); // Don't go negative
            domain.1 += expansion;
        }
        
        let breaks = self
            .breaks
            .unwrap_or_else(|| extended_breaks(domain, 5));
        
        let labels = self.labels.unwrap_or_else(|| {
            breaks.iter().map(|b| format!("{:.2}", b)).collect()
        });

        if breaks.len() != labels.len() {
            return Err(PlotError::ScaleError(
                format!("Breaks and labels must have the same length: {} breaks vs {} labels",
                    breaks.len(), labels.len())
            ));
        }

        Ok(Sqrt {
            domain,
            breaks,
            labels,
            trained: self.limits.is_some(),
        })
    }

    /// Build a log10 (base-10 logarithmic) scale.
    /// 
    /// Creates a scale that maps data values to normalized coordinates using
    /// a logarithmic transformation: `f(x) = log₁₀(x)`.
    /// 
    /// This transformation is ideal for data that spans several orders of magnitude,
    /// as it spaces out small values and compresses large values. Common uses include
    /// financial data, population sizes, or any multiplicative processes.
    /// 
    /// Note: The domain must contain only positive values (log is undefined for x ≤ 0).
    /// 
    /// # Returns
    /// 
    /// * `Ok(Log10)` - A configured log10 scale
    /// * `Err(PlotError::ScaleError)` - If breaks and labels have mismatched lengths,
    ///   or if the domain contains non-positive values
    /// 
    /// # Examples
    /// 
    /// ```ignore
    /// let scale = Continuous::new()
    ///     .limits((1.0, 1000.0))
    ///     .breaks(vec![1.0, 10.0, 100.0, 1000.0])
    ///     .log10()?;
    /// ```
    pub fn log10(self) -> Result<Log10, PlotError> {
        let mut domain = self.limits.unwrap_or((1.0, 10.0));
        
        if domain.0 <= 0.0 || domain.1 <= 0.0 {
            return Err(PlotError::ScaleError(
                format!("Log10 scale requires positive domain, got ({}, {})",
                    domain.0, domain.1)
            ));
        }
        
        // Apply expansion (multiplicative expansion makes more sense for log scales)
        if let Some((mult, add)) = self.expand {
            let range = domain.1 - domain.0;
            let expansion = range * mult + add;
            domain.0 = (domain.0 - expansion).max(0.001); // Don't go to zero or negative
            domain.1 += expansion;
        }
        
        let breaks = self
            .breaks
            .unwrap_or_else(|| extended_breaks(domain, 5));
        
        let labels = self.labels.unwrap_or_else(|| {
            breaks.iter().map(|b| format!("{:.2}", b)).collect()
        });

        if breaks.len() != labels.len() {
            return Err(PlotError::ScaleError(
                format!("Breaks and labels must have the same length: {} breaks vs {} labels",
                    breaks.len(), labels.len())
            ));
        }

        Ok(Log10 {
            domain,
            breaks,
            labels,
            trained: self.limits.is_some(),
        })
    }
}

pub struct Linear {
    pub(crate) domain: (f64, f64),
    pub(crate) breaks: Vec<f64>,
    pub(crate) labels: Vec<String>,
    trained: bool, // Track if domain was explicitly set or should be auto-calculated
    lower_bound: Option<f64>, // Optional lower bound the domain must respect
    upper_bound: Option<f64>, // Optional upper bound the domain must respect
}

impl ScaleBase for Linear {
    fn train(&mut self, data: &[&dyn crate::data::GenericVector]) {
        // Only auto-train if domain wasn't explicitly set
        if !self.trained {
            if let Some((mut min, mut max)) = compute_min_max(data) {
                
                // Respect lower bound if set
                if let Some(lower) = self.lower_bound {
                    min = min.min(lower);
                }
                
                // Respect upper bound if set
                if let Some(upper) = self.upper_bound {
                    max = max.max(upper);
                }
                
                // Apply expansion (5% by default)
                let range = max - min;
                let expansion = if range.abs() < 1e-10 {
                    // Degenerate case: all values are the same
                    // Create a range around the value
                    if min.abs() < 1e-10 {
                        1.0  // For values near zero, use ±1
                    } else {
                        min.abs() * 0.1  // Otherwise use ±10% of the value
                    }
                } else {
                    range * 0.05
                };
                
                // Don't expand past bounds
                let lower_expansion = if self.lower_bound.is_some() && min == self.lower_bound.unwrap() {
                    0.0
                } else {
                    expansion
                };
                let upper_expansion = if self.upper_bound.is_some() && max == self.upper_bound.unwrap() {
                    0.0
                } else {
                    expansion
                };
                
                self.domain = (min - lower_expansion, max + upper_expansion);
                
                // Regenerate breaks and labels
                self.breaks = extended_breaks(self.domain, 5);
                self.labels = self.breaks.iter().map(|b| {
                    if b.abs() < 1e-10 {
                        "0".to_string()
                    } else if b.abs() >= 1000.0 || b.abs() < 0.01 {
                        format!("{:.1e}", b)
                    } else if b.fract().abs() < 1e-10 {
                        format!("{:.0}", b)
                    } else {
                        format!("{:.2}", b).trim_end_matches('0').trim_end_matches('.').to_string()
                    }
                }).collect();
                
                self.trained = true;
            }
        }
    }
}

impl ContinuousScale for Linear {
    fn map_value(&self, data: f64) -> Option<f64> {
        let (d0, d1) = self.domain;
        // Check if value is within domain bounds
        if data < d0.min(d1) || data > d0.max(d1) {
            return None;
        }
        // Map to normalized [0, 1] coordinates
        Some((data - d0) / (d1 - d0))
    }

    fn inverse(&self, value: f64) -> f64 {
        let (d0, d1) = self.domain;
        // Map from normalized [0, 1] to data domain
        d0 + value * (d1 - d0)
    }

    fn breaks(&self) -> &[f64] {
        &self.breaks
    }

    fn labels(&self) -> &[String] {
        &self.labels
    }
}

pub struct Sqrt {
    pub(crate) domain: (f64, f64),
    pub(crate) breaks: Vec<f64>,
    pub(crate) labels: Vec<String>,
    trained: bool,
}

impl ScaleBase for Sqrt {
    fn train(&mut self, data: &[&dyn crate::data::GenericVector]) {
        if !self.trained {
            if let Some((min, max)) = compute_min_max(data) {
                let min = min.max(0.0);  // Clamp to non-negative for sqrt
                
                let range = max - min;
                let expansion = if range.abs() < 1e-10 {
                    // Degenerate case: all values are the same
                    if min.abs() < 1e-10 {
                        1.0  // For values near zero, use ±1
                    } else {
                        min.abs() * 0.1  // Otherwise use ±10% of the value
                    }
                } else {
                    range * 0.05
                };
                self.domain = (min - expansion, max + expansion);
                self.domain.0 = self.domain.0.max(0.0); // Don't go negative
                
                self.breaks = extended_breaks(self.domain, 5);
                self.labels = self.breaks.iter().map(|b| {
                    if b.abs() < 1e-10 {
                        "0".to_string()
                    } else if b.abs() >= 1000.0 || b.abs() < 0.01 {
                        format!("{:.1e}", b)
                    } else if b.fract().abs() < 1e-10 {
                        format!("{:.0}", b)
                    } else {
                        format!("{:.2}", b).trim_end_matches('0').trim_end_matches('.').to_string()
                    }
                }).collect();
                
                self.trained = true;
            }
        }
    }
}

impl ContinuousScale for Sqrt {
    fn map_value(&self, data: f64) -> Option<f64> {
        let (d0, d1) = self.domain;
        // Check if value is within domain bounds
        if data < d0.min(d1) || data > d0.max(d1) {
            return None;
        }
        // Map to normalized [0, 1] using sqrt transformation
        let sqrt_data = data.sqrt();
        let sqrt_d0 = d0.sqrt();
        let sqrt_d1 = d1.sqrt();
        Some((sqrt_data - sqrt_d0) / (sqrt_d1 - sqrt_d0))
    }

    fn inverse(&self, value: f64) -> f64 {
        let (d0, d1) = self.domain;
        let sqrt_d0 = d0.sqrt();
        let sqrt_d1 = d1.sqrt();
        // Map from normalized [0, 1] to data domain
        let scaled = sqrt_d0 + value * (sqrt_d1 - sqrt_d0);
        scaled * scaled
    }

    fn breaks(&self) -> &[f64] {
        &self.breaks
    }

    fn labels(&self) -> &[String] {
        &self.labels
    }
}

pub struct Log10 {
    pub(crate) domain: (f64, f64),
    pub(crate) breaks: Vec<f64>,
    pub(crate) labels: Vec<String>,
    trained: bool,
}

impl ScaleBase for Log10 {
    fn train(&mut self, data: &[&dyn crate::data::GenericVector]) {
        if !self.trained {
            if let Some((min, max)) = compute_min_max(data) {
                let min = min.max(0.001);  // Clamp to positive values for log
                let range = max - min;
                let expansion = if range.abs() < 1e-10 {
                    // Degenerate case: all values are the same
                    // For log scale, use multiplicative expansion
                    min * 0.1
                } else {
                    range * 0.05
                };
                self.domain = ((min - expansion).max(0.001), max + expansion);
                
                self.breaks = extended_breaks(self.domain, 5);
                self.labels = self.breaks.iter().map(|b| {
                    if b.abs() < 1e-10 {
                        "0".to_string()
                    } else if b.abs() >= 1000.0 || b.abs() < 0.01 {
                        format!("{:.1e}", b)
                    } else if b.fract().abs() < 1e-10 {
                        format!("{:.0}", b)
                    } else {
                        format!("{:.2}", b).trim_end_matches('0').trim_end_matches('.').to_string()
                    }
                }).collect();
                
                self.trained = true;
            }
        }
    }
}

impl ContinuousScale for Log10 {
    fn map_value(&self, data: f64) -> Option<f64> {
        let (d0, d1) = self.domain;
        // Check if value is within domain bounds
        if data < d0.min(d1) || data > d0.max(d1) {
            return None;
        }
        // Map to normalized [0, 1] using log10 transformation
        let log_data = data.log10();
        let log_d0 = d0.log10();
        let log_d1 = d1.log10();
        Some((log_data - log_d0) / (log_d1 - log_d0))
    }

    fn inverse(&self, value: f64) -> f64 {
        let (d0, d1) = self.domain;
        let log_d0 = d0.log10();
        let log_d1 = d1.log10();
        // Map from normalized [0, 1] to data domain
        let scaled = log_d0 + value * (log_d1 - log_d0);
        10_f64.powf(scaled)
    }

    fn breaks(&self) -> &[f64] {
        &self.breaks
    }

    fn labels(&self) -> &[String] {
        &self.labels
    }
}

/// Helper function to compute min and max from a slice of GenericVectors
/// without copying all the data. Returns None if all vectors are empty.
fn compute_min_max(data: &[&dyn crate::data::GenericVector]) -> Option<(f64, f64)> {
    let mut min = f64::INFINITY;
    let mut max = f64::NEG_INFINITY;
    let mut found_any = false;
    
    for vec in data {
        if let Some(float_vec) = vec.as_float() {
            for &value in float_vec.iter() {
                min = min.min(value);
                max = max.max(value);
                found_any = true;
            }
        } else if let Some(int_vec) = vec.as_int() {
            for &value in int_vec.iter() {
                let value_f64 = value as f64;
                min = min.min(value_f64);
                max = max.max(value_f64);
                found_any = true;
            }
        }
    }
    
    if found_any {
        Some((min, max))
    } else {
        None
    }
}

/// Generate axis breaks using Wilkinson's Extended algorithm.
/// Returns a vector of break positions given a data range and desired number of breaks.
pub fn extended_breaks(domain: (f64, f64), n: usize) -> Vec<f64> {
    // Nice numbers to use for step sizes
    const Q: [f64; 5] = [1.0, 5.0, 2.0, 2.5, 4.0];

    let (min, max) = domain;
    if n < 2 {
        return vec![min, max];
    }
    
    // Handle degenerate case: single value
    if (min - max).abs() < 1e-10 {
        // Create a symmetric range around the value
        if min.abs() < 1e-10 {
            // Value is ~0, create range around 0
            return vec![-1.0, 0.0, 1.0];
        } else {
            // Create range ±10% around the value
            let range = min.abs() * 0.1;
            return vec![min - range, min, min + range];
        }
    }
    let range = max - min;
    let mut best_score = std::f64::NEG_INFINITY;
    let mut best = vec![min, max];

    for &q in &Q {
        let w = (range / (n as f64 - 1.0)) / q;
        let step = q * 10f64.powf(w.log10().floor());
        let start = (min / step).floor() * step;
        let end = (max / step).ceil() * step;
        let mut breaks = Vec::new();
        let mut x = start;
        while x <= end + 1e-10 {
            breaks.push(x);
            x += step;
        }
        // Score: coverage, simplicity, density, legibility (simplified)
        let coverage = (min - breaks[0]).abs() + (breaks.last().unwrap() - max).abs();
        let simplicity = if q == 1.0 { 1.0 } else { 0.5 };
        let density = ((breaks.len() as f64 - n as f64).abs()) as f64;
        let score = -coverage - density + simplicity;
        if score > best_score {
            best_score = score;
            best = breaks;
        }
    }
    best
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils::dataframe::FloatVec;

    #[test]
    fn test_extended_breaks_basic() {
        let breaks = extended_breaks((0.0, 10.0), 5);
        assert_eq!(breaks, vec![0.0, 2.5, 5.0, 7.5, 10.0]);
    }

    #[test]
    fn test_extended_breaks_negative() {
        let breaks = extended_breaks((-5.0, 5.0), 5);
        assert_eq!(breaks, vec![-5.0, -2.5, 0.0, 2.5, 5.0]);
    }

    #[test]
    fn test_extended_breaks_single_value_zero() {
        // When min == max and close to zero, should return [-1, 0, 1]
        let breaks = extended_breaks((0.0, 0.0), 5);
        assert_eq!(breaks, vec![-1.0, 0.0, 1.0]);
    }

    #[test]
    fn test_extended_breaks_single_value_nonzero() {
        // When min == max and non-zero, should return symmetric range around value
        let breaks = extended_breaks((10.0, 10.0), 5);
        assert_eq!(breaks, vec![9.0, 10.0, 11.0]);
    }

    #[test]
    fn test_extended_breaks_single_value_negative() {
        // Test with negative single value
        let breaks = extended_breaks((-5.0, -5.0), 5);
        assert_eq!(breaks, vec![-5.5, -5.0, -4.5]);
    }

    #[test]
    fn test_linear_scale_degenerate_zero() {
        // Test Linear scale with all values at zero
        // Using Builder without limits means train() will be called
        let mut scale = Continuous::new().linear().unwrap();
        let data = FloatVec(vec![0.0, 0.0, 0.0, 0.0]);
        scale.train(&[&data]);
        
        // Should have symmetric domain around zero
        assert!(scale.domain.0 < 0.0, "domain.0 should be < 0.0, got {}", scale.domain.0);
        assert!(scale.domain.1 > 0.0, "domain.1 should be > 0.0, got {}", scale.domain.1);
        
        // Should be able to map the value without division by zero
        let mapped = scale.map_value(0.0);
        assert!(mapped.is_some(), "Should be able to map 0.0");
        // Value should map near the middle of the range
        assert!((mapped.unwrap() - 0.5).abs() < 0.1, "0.0 should map near 0.5, got {}", mapped.unwrap());
    }

    #[test]
    fn test_linear_scale_degenerate_nonzero() {
        // Test Linear scale with all values at 5.0
        let mut scale = Continuous::new().linear().unwrap();
        let data = FloatVec(vec![5.0, 5.0, 5.0]);
        scale.train(&[&data]);
        
        // Should have symmetric domain around 5.0
        assert!(scale.domain.0 < 5.0, "domain.0 should be < 5.0, got {}", scale.domain.0);
        assert!(scale.domain.1 > 5.0, "domain.1 should be > 5.0, got {}", scale.domain.1);
        
        // Should be able to map the value without division by zero
        let mapped = scale.map_value(5.0);
        assert!(mapped.is_some(), "Should be able to map 5.0");
        // Value should map near the middle of the range
        assert!((mapped.unwrap() - 0.5).abs() < 0.1, "5.0 should map near 0.5, got {}", mapped.unwrap());
    }

    #[test]
    fn test_sqrt_scale_degenerate() {
        // Test Sqrt scale with all values at 4.0
        let mut scale = Continuous::new().sqrt().unwrap();
        let data = FloatVec(vec![4.0, 4.0, 4.0]);
        scale.train(&[&data]);
        
        // Should have symmetric domain around 4.0
        assert!(scale.domain.0 < 4.0, "domain.0 should be < 4.0, got {}", scale.domain.0);
        assert!(scale.domain.1 > 4.0, "domain.1 should be > 4.0, got {}", scale.domain.1);
        
        // Should be able to map the value without division by zero
        let mapped = scale.map_value(4.0);
        assert!(mapped.is_some(), "Should be able to map 4.0");
        // Value should map near the middle of the range
        assert!((mapped.unwrap() - 0.5).abs() < 0.1, "4.0 should map near 0.5, got {}", mapped.unwrap());
    }

    #[test]
    fn test_log10_scale_degenerate() {
        // Test Log10 scale with all values at 10.0
        let mut scale = Continuous::new().log10().unwrap();
        let data = FloatVec(vec![10.0, 10.0, 10.0]);
        scale.train(&[&data]);
        
        // Should have expanded domain around 10.0
        assert!(scale.domain.0 < 10.0, "domain.0 should be < 10.0, got {}", scale.domain.0);
        assert!(scale.domain.1 > 10.0, "domain.1 should be > 10.0, got {}", scale.domain.1);
        
        // Should be able to map the value without division by zero
        let mapped = scale.map_value(10.0);
        assert!(mapped.is_some(), "Should be able to map 10.0");
        // Value should map near the middle of the range
        assert!((mapped.unwrap() - 0.5).abs() < 0.1, "10.0 should map near 0.5, got {}", mapped.unwrap());
    }

    #[test]
    fn test_linear_scale_degenerate_preserves_normal_behavior() {
        // Ensure the fix doesn't break normal scaling
        let mut scale = Continuous::new().linear().unwrap();
        let data = FloatVec(vec![0.0, 10.0]);
        scale.train(&[&data]);
        
        // With 5% expansion on each side, domain is approximately [-0.5, 10.5]
        // So 0.0 maps to about 0.048 (0.5 / 10.5), not exactly 0.0
        let map_0 = scale.map_value(0.0).unwrap();
        let map_10 = scale.map_value(10.0).unwrap();
        let map_5 = scale.map_value(5.0).unwrap();
        
        assert!(map_0 < 0.1, "0.0 should map near the start, got {}", map_0);
        assert!(map_10 > 0.9, "10.0 should map near the end, got {}", map_10);
        assert!((map_5 - 0.5).abs() < 0.1, "5.0 should map near 0.5, got {}", map_5);
    }

    #[test]
    fn test_sqrt_scale_degenerate_preserves_normal_behavior() {
        // Ensure the fix doesn't break normal scaling
        let mut scale = Continuous::new().sqrt().unwrap();
        let data = FloatVec(vec![0.0, 100.0]);
        scale.train(&[&data]);
        
        let map_0 = scale.map_value(0.0).unwrap();
        let map_100 = scale.map_value(100.0).unwrap();
        let map_25 = scale.map_value(25.0).unwrap();
        
        assert!(map_0 < 0.1, "0.0 should map near the start, got {}", map_0);
        assert!(map_100 > 0.9, "100.0 should map near the end, got {}", map_100);
        // sqrt(25) = 5, halfway between sqrt(0)=0 and sqrt(100)=10
        assert!((map_25 - 0.5).abs() < 0.1, "25.0 should map near 0.5, got {}", map_25);
    }

    #[test]
    fn test_log10_scale_degenerate_preserves_normal_behavior() {
        // Ensure the fix doesn't break normal scaling
        let mut scale = Continuous::new().log10().unwrap();
        let data = FloatVec(vec![1.0, 100.0]);
        scale.train(&[&data]);
        
        let map_1 = scale.map_value(1.0).unwrap();
        let map_100 = scale.map_value(100.0).unwrap();
        let map_10 = scale.map_value(10.0).unwrap();
        
        // With expansion and clamping to 0.001, the domain in log space is wider
        // Just verify the relative ordering is correct
        assert!(map_1 < map_10, "1.0 should map before 10.0");
        assert!(map_10 < map_100, "10.0 should map before 100.0");
        // 10 is the geometric mean of 1 and 100, so should be in the middle region
        assert!(map_10 > 0.3 && map_10 < 0.9, "10.0 should map in middle region, got {}", map_10);
    }
}